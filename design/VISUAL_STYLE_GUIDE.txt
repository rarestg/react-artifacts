Codex Conversation Manager — Visual Design Guide (Sharp UI System)

Purpose
This guide defines the long-term visual and interaction standards for Codex
Conversation Manager. It replaces older “glassy / pill / card” conventions with a
sharp, scan-first, devtool-native system.

Use this guide when:
- adding UI
- refactoring UI
- introducing new primitives (tags, panels, lists, controls)
- reviewing PRs for visual consistency, accessibility, and interaction quality

Non-goals
- This is not a one-off migration plan (“make it sharp”). That plan can live in
  /todos and eventually /done-tasks.
- This is not a full design system for all products. It’s tailored to this repo’s
  devtool UI: dense, readable, keyboard-safe, and consistent.


============================================================
1) Product Aesthetic and Constraints (Hard Rules)
============================================================

Sharp UI Rules
1) No rounded corners (radius = 0)
   - Applies to: panels, rows, tags, inputs, modals, code blocks, badges.
   - Any exception must be documented inline (comment) and in this guide.

2) No translucency / glass / blur
   - No alpha surfaces like bg-white/80, bg-slate-50/80.
   - No backdrop-blur.
   - One exception: modal overlay scrim may use a single controlled overlay token.

3) No shadows for hierarchy
   - Don’t use shadow-card / shadow-sm / “glow” to separate surfaces.
   - Hierarchy is expressed via: borders, typography, spacing, and grouping.

4) Preserve keyboard focus visibility
   - Focus must be obvious, consistent, and never clipped.
   - Focus rings (box-shadow) are allowed as an accessibility exception for keyboard focus.
   - Do not use shadow/glow for hierarchy; if using rings, keep them single-color and high-contrast.

5) Preserve the existing spacing rhythm
   - Do not “fix” sharpness by changing spacing everywhere.
   - Make the UI sharper by changing surfaces + states, not by compressing layout.


============================================================
2) Core Principles (How the UI Should Feel)
============================================================

1) Scan-first
   - Lists, sessions, workspaces, and search results should be readable at a glance.
   - Prefer structured rows over nested tiles/cards.

2) Dense, not cramped
   - Density comes from alignment and structure, not tiny tap targets.
   - Hit areas must remain generous and accessible.

3) Clear hierarchy without decoration
   - Use borders and typographic weight to show “what is a container” and “what is a row”.
   - Avoid “borders inside borders inside borders” (nested border fatigue).

4) State-driven interaction
   - Hover/focus/selected/active states are the affordance.
   - If something is clickable, it must behave clickable.

5) Accessibility is not optional
   - Color is never the only cue.
   - Keyboard navigation must always have a visible focus state.
   - Motion respects prefers-reduced-motion when motion is implemented.


============================================================
3) Tokens and Naming (Design Language)
============================================================

Tokens (Conceptual)
- Surfaces: surface-0 (panel), surface-1 (muted grouping), surface-2 (pressed/strong hover)
- Borders: border, border-muted, border-strong
- Text: text-0 (primary), text-1 (secondary), text-2 (muted)
- Accent: accent (focus + selection), accent-muted (optional selection/hover helpers)
- Overlay: overlay (modal scrim only)

Naming
- “Tag” is the preferred concept name.
- The codebase may keep the class name “chip” temporarily to reduce churn, but it
  should mean “sharp tag”, not a rounded pill.


============================================================
4) Layout and Spacing Rhythm
============================================================

Rule: One spacing system per stack
- Use a single parent gap (gap-* or space-y-*) to control vertical rhythm inside a section.
- Avoid mixing parent gaps with ad-hoc child margins (mt-*, mb-*) unless there is a
  documented exception.
- If spacing feels off, change the parent gap instead of patching child margins.

Baseline rhythm (guidance, not a mandate)
- Internal stacks: gap-3 is the default cadence.
- Tight stacks (lists/rows): gap-2 or divider-based separation is often better than bigger gaps.
- Avoid “floating tiles” created by: space-y + per-item borders + big radii (banned anyway).

Grid safety
- Always define explicit columns at all breakpoints (grid-cols-1, etc.).
- Always use min-w-0 on grid children that contain truncating text.
- Use truncation intentionally (truncate / line-clamp) to prevent horizontal bleed.


============================================================
5) Surfaces and Containers
============================================================

Surface primitives (conceptual)
- Panel: bordered, opaque, sharp edges. Used for primary containers.
- Muted panel: subtle background for grouping. Prefer no border by default.
- Dashed panel: empty/placeholder states.

Hierarchy strategy
- Outer containers get borders.
- Inner groupings often get background only (no border) to prevent border stacking.
- Use headers + dividers inside panels for structure instead of nested cards.

Empty states
- Use dashed border + clear copy.
- Empty states are content blocks, not interactive elements.


============================================================
6) Lists and Rows (Scan-First Contract)
============================================================

Where rows are required
- Sessions list
- Workspaces list
- Search results list
- Tool call/event lists
- Any repeated, comparable items where the user scans and selects

Row structure (recommended)
- One list container + separators (divide-y or border-top on siblings)
- Rows should not be individual bordered “tiles” with gaps unless there is a clear reason.
- Rows may be 1–2 lines. Multi-paragraph content belongs in a details panel/block.

States (must exist for interactive rows)
- Hover: subtle background shift and/or hint (cursor, underline, etc.)
- Focus-visible: high-contrast focus indicator (outline or ring)
- Active/pressed: slightly stronger background shift
- Selected: persistent left accent bar + background shift

Selection vs Focus (do not conflate)
- Selected = the item currently shown in the details/content pane.
- Focused = where keyboard navigation is currently located.
- These may be different; the UI must support both states.

Numeric scanability
- Use tabular-nums for numeric-heavy chips/tags/columns.
- Align metrics consistently (same column positions across rows when possible).


============================================================
7) Focus and Keyboard Navigation (Hard Requirements)
============================================================

Focus contract
- Use a single, consistent focus-visible style across buttons, inputs, row buttons, tags.
- Use focus-visible (keyboard-only), not focus (mouse clicks should not show focus).
- Ring-based focus is allowed and preferred when outlines are too subtle (e.g., dark/filled controls).
- Do not rely on subtle dimming alone; focus must remain obvious on filled/dark buttons.
- Focus rings should include a small offset (1px) so the ring does not touch the control edge.
- Use a single ring color across controls (default: `ring-slate-400`) to avoid per-component tweaks.
- Use one primary focus cue per component: rows use left bar + background; controls use ring. Do not stack both.
- Focus must not be clipped:
  - Avoid overflow-hidden on focusable ancestors OR use inset outlines intentionally.
  
ARIA sanity (dropdowns, listboxes)
- Only use ARIA attributes supported by the element/role (e.g., aria-activedescendant belongs on a combobox/input role, not a plain button).

Compound controls
- If an input is visually hidden (sr-only), the visible wrapper must show focus-within.
  Example: toggles implemented as label + hidden checkbox must still show focus.

Keyboard affordance
- If an action appears on hover, it must also appear on focus-within (keyboard).
- All interactive elements must be reachable and visually focusable.


============================================================
8) Controls and Inputs
============================================================

Inputs / Selects
- Sharp edges, opaque background, border-driven focus.
- Ring-based focus is allowed for keyboard focus; it must be high-contrast and obvious.
- Error states are border + text (not shadows).
- Prefer custom listbox popovers for selects:
  - Trigger is a sharp button.
  - Options are rows with hover/active/selected states.
  - Escape closes the menu; Enter/Space selects.

Buttons
- Sharp edges, border-driven hierarchy.
- Hover/pressed states must be visible without shadows.
- Use consistent padding and text sizing.
- Inputs and buttons should share a consistent control height (e.g., h-9) so focus geometry aligns.
  - Applies to interactive controls; metadata chips may be shorter.

Toggles (recommended approach)
- Prefer checkbox-style controls for “sharp devtool” feel.
- If a switch UI is used, it must not depend on rounded track/knob.
- Toggle containers must have focus-within styling (common regression risk).


============================================================
9) Tags (Status, Labels, Chips)
============================================================

Tag principles
- Tags are informational labels, counts, or quick states.
- Tags are not “decorative pills”.
- Keep variants minimal (2–3 variants total):
  - Base (bordered)
  - Muted (subtle background)
  - Solid (CTA/emphasis)

Tag usage
- Metadata: repo, branch, timestamps, counts
- Filters: active filters, scopes
- Status: indexed, searching, connected, shortcuts enabled

Do not rely on color alone
- If state matters, provide a second cue:
  - fill vs hollow indicator
  - text tone (muted vs normal)
  - explicit label (“On” / “Off” where appropriate)
  - sr-only text that includes the state

Status indicator (recommended)
- Use a small square indicator sub-element:
  - active: filled block
  - inactive: hollow block (border only)
- This supports a TUI-adjacent aesthetic and avoids radius exceptions.

Stable width rule for labels that change
- When a tag/button label changes (e.g., “On” -> “Off”), reserve width to avoid UI jitter.
- Preferred technique: “reserve label overlay” (see section 11).


============================================================
10) Content Blocks (Conversation, Markdown, Code)
============================================================

Narrative content stays block-based
- Turns and messages are content blocks (not table rows).
- Avoid converting conversation content into grid/table layouts.
- The scan-first principle applies to the chrome and lists around content, not to paragraphs.

Markdown + code
- Code blocks are sharp containers (border + solid background, no rounding).
- Inline code is minimal (border or subtle background), no pill styling.
- Keep line-height readable; do not over-tighten markdown.

Highlights (search snippets)
- Highlights should be sharp (no rounding) and subtle.
- Avoid high-saturation “marker” colors that dominate reading.


============================================================
11) Label Width Stability (No Layout Shift)
============================================================

Why it matters
- In a scan-first UI, small layout shifts (changing widths) feel sloppy and distract users.
- Any UI element with swapping text should preserve width.

Approved pattern: Reserve label overlay
- Render an invisible “reserve” label to establish width.
- Render the current label on top (grid overlay preferred).

Example pattern (conceptual)
- Wrapper: relative inline-grid
- Reserve: opacity-0, aria-hidden, pointer-events-none
- Visible label: in the same grid cell, truncation allowed

Notes
- This is already the approach used in CopyButton; follow the same pattern.
- Use this for StatusTag/StatusPill when label changes between states (“on/off”).
- Inset rings do not increase outer size; if positioning a label against an outer ring, subtract the inset ring thickness (e.g., 2px) from the offset.


============================================================
12) Copy UX Standard (CopyButton + Copy Interactions)
============================================================

Copy is a first-class action in this devtool.
Copy interactions must be:
- stable (no width jump)
- fast
- accessible (announced)
- predictable across the app

CopyButton rules
1) Single control with overlay labels
   - Idle/hover/copied/failed labels swap using overlays.
   - Width must remain stable (reserve label).

2) Inline success/failure feedback
   - Success/failure icons appear inline with the status label (e.g., “Copied ✓”).
   - Do not reserve a separate icon slot.

3) Hover label handling
   - hoverLabel defaults to “Copy”.
   - Set hoverLabel={null} to disable hover swapping.

4) Accessibility
   - Must announce results via aria-live output.
   - If idleLabel is not a string, provide ariaLabel.

5) Focus
   - CopyButton must always show focus-visible (do not rely on chip/button wrappers).


============================================================
13) Modals and Overlays
============================================================

Modal rules
- Modal surface is opaque and bordered.
- No glass, no blur, no shadow hierarchy.
- Use a single overlay token for the backdrop scrim (allowed exception).

Layering cues (without shadows)
- Use borders, header bars, and clear spacing.
- Make the modal boundary unmistakable (strong border, clear title row).

Keyboard
- Focus trap must be correct (implementation detail), but visually:
  - focus-visible must remain obvious on all elements inside the modal.


============================================================
14) Motion
============================================================

Motion should never be “decorative gloss” in this UI.
- Avoid stagger/float animations that read as consumer UI polish.
- If animations exist, keep them subtle and functional (feedback, not decoration).
- If reduced-motion support is implemented, it must:
  - reduce durations
  - remove repeated animations
  - disable parallax-like behaviors


============================================================
15) Consistency Checklist (PR Review)
============================================================

Sharp rules
- Any rounded corners? (rounded-*) -> remove (or document exception)
- Any translucency? (bg-*/80, opacity tricks) -> remove
- Any blur? (backdrop-blur) -> remove
- Any shadow used for hierarchy? -> remove

Focus and states
- Can I tab through and always see focus?
- Do interactive rows have hover + focus-visible + active states?
- Is selected state distinct from focus state?
- For selectable rows, reserve the left bar for selection; focus-visible should use background only.

Layout
- One spacing system per stack (gap/space-y vs mt/mb)?
- Grids define columns at all breakpoints?
- min-w-0 used where truncation is expected?

Lists
- Are repeated items presented as rows (not tiles) where scan/compare is needed?
- Are separators handled by the list container (divide-y) rather than per-item cards?

Copy + label stability
- Do swapping labels reserve width (no jitter)?
- CopyButton follows the overlay label pattern and remains accessible?

Accessibility
- Is color the only cue? If yes, add a non-color cue + sr text.
- Are icon-only buttons labeled?

Vendor
- Scrollbar handles sharp (no forced rounding)?
- Any third-party rounding documented?


============================================================
16) Spacing/State Debug Playbook
============================================================

If spacing looks wrong
1) Inspect both boundaries that form the perceived gap.
2) Look for stacked spacing: parent gap/space-y + child mt/mb.
3) Consolidate to a single parent gap wherever possible.
4) Use temporary outlines on adjacent blocks to measure reliably.

If “clickability” feels unclear
1) Confirm hover exists and is visible.
2) Confirm focus-visible exists and is visible.
3) Confirm active/pressed exists for pointer users.
4) Confirm hit area is large enough (don’t shrink padding to gain density).

If UI feels “busy” after removing shadows
1) Reduce nested borders (use muted background without border).
2) Prefer list separators over bordered tiles.
3) Use headers and typographic weight for structure.


============================================================
17) Exceptions Policy
============================================================

Sometimes you can’t avoid a violation (third-party components, vendor UIs).
When an exception is necessary:
- Keep it as small and localized as possible.
- Document it:
  - inline comment in the component/CSS
  - add a note here if it’s recurring or system-wide
- Prefer fixing upstream styling hooks (vendor overrides) over accepting inconsistency.


== THE FOLLOWING RULES ARE APPLICABLE TO MESSAGE RENDERING IN CONVERSATIONS / TURNS
== BETWEEN USER AND ASSISTANT, SINCE WE LIKELY USE MARKDOWN RENDERERS AND MONOSPACED
== FONTS TO RENDER A CONVERSATION THAT TOOK PLACE IN THE TERMINAL


============================================================
Typography and Message Rendering (Terminal-Adjacent Rules)
============================================================

Goals
- Terminal-adjacent readability: mono-forward content, scan-first structure.
- Accuracy: user input should be represented faithfully.
- Safety: markdown rendering must be sanitized and never execute raw HTML.
- Resilience: message rendering must not crash a turn if the markdown pipeline fails.

Font policy
1) UI chrome vs message content
   - UI chrome (navigation, panels, lists, headers): UI font (sans/system).
   - Conversation content (user/assistant/thought/tool/meta): mono-forward.
   - Numeric-heavy UI: tabular numerals (tabular-nums) where applicable.

2) No font switching inside conversation content
   - Markdown headings, lists, and emphasis must not switch to a different font family.
   - Emphasis uses weight/style (bold/italic/underline), not a font change.

3) Pick a mono font that supports emphasis
   - Prefer monospace families with good bold + italic so markdown emphasis doesn’t look broken.
   - If italic renders poorly (fake oblique), consider mapping <em> to underline in markdown styling.

Rendering policy by message type
1) User messages (default: literal)
   - Default rendering is literal text (no markdown parsing).
   - Preserve whitespace and characters exactly as typed.
   - Use a pre-wrap style (whitespace-pre-wrap) so prompts remain readable without horizontal scrolling.
   - Optional: provide a user-visible toggle to “Render Markdown” for that message or globally.

2) Assistant + thought messages (default: rendered markdown)
   - Render markdown (GFM allowed) with sanitization.
   - Keep markdown styling terminal-adjacent:
     - headings are subtle (avoid huge type jumps)
     - lists are clean and compact
     - code blocks are sharp containers (border + solid bg, no radius)
     - inline code is minimal (no pill styling)

3) Tool calls / tool output / meta (always literal)
   - Never parse as markdown.
   - Always render inside a code-block container (<pre> / monospace).
   - Prefer horizontal scroll for very long lines; avoid wrapping JSON unless explicitly formatted.

4) Token telemetry (structured)
   - TokenCount entries render as structured UI, not markdown.

Fallback rule (must not crash)
- The markdown renderer may fail due to plugin/transform bugs or malformed injected markup.
- Wrap markdown rendering in an error boundary and fall back to literal rendering:
  - show raw text in a code-block container
  - do not crash the whole turn/session view

Security rule
- Do not render unsanitized HTML from any message content.
- If a pipeline requires raw HTML for internal features (e.g., search highlights),
  sanitize and restrict allowed elements/attributes.
- User messages should never be allowed to inject HTML into the UI.

Copy behavior alignment
- Always support copying the raw source:
  - User: Copy raw text
  - Assistant: Copy markdown source and/or Copy plain text
- Copy interactions must preserve width and avoid layout shift (reserve label overlay).

Search highlighting
- Search highlighting must not break code or inline code rendering.
- When highlighting in markdown, avoid injecting highlights inside code fences/inline code.
- When highlighting literal user text, prefer a safe highlighter that does not interpret HTML.

End of guide.
