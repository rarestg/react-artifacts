Codex Conversation Manager — Visual Design Guide (Sharp UI System)

Purpose
Defines long-term visual and interaction standards for this repo. Replaces the
older “glassy / pill / card” conventions with a sharp, scan-first, devtool UI.

Use this guide when:
- adding UI
- refactoring UI
- introducing new primitives (tags, panels, lists, controls)
- reviewing PRs for visual consistency, accessibility, and interaction quality

Non-goals
- This is not a one-off migration plan.
- This is not a full design system for all products.


============================================================
1) Hard Rules (Sharp UI)
============================================================

- No rounded corners (radius = 0). Document exceptions inline + here.
- No translucency / glass / blur (single overlay token only for modal scrim).
- No shadows for hierarchy; use borders, typography, spacing, grouping instead.
- Focus must be obvious and not clipped; ring focus is allowed for keyboard.
- Preserve spacing rhythm; sharpen surfaces + states, not layout density.


============================================================
2) Core Principles
============================================================

- Scan-first: lists and results should read at a glance.
- Dense, not cramped: generous hit targets, clean alignment.
- Hierarchy via borders + type; avoid nested border fatigue.
  - One nested border level is acceptable when it improves scanability.
  - Depth 3+ borders require a documented exception.
- State-driven interaction: hover/focus/selected/active must read as interactive.
- Accessibility: color is never the only cue; respect prefers-reduced-motion.


============================================================
3) Tokens & Theming
============================================================

Tokens (conceptual)
- Surfaces, borders, text, accent, ring, highlight, overlay.

Token contract (Base)
- Base theme must define light + dark tokens.
- Components must use tokens (var(--...)), not raw colors.
- Required tokens:
  - --surface, --surface-muted, --surface-strong
  - --text, --text-muted
  - --border, --border-strong
  - --ring
  - --accent, --accent-weak
  - --highlight
  - Any semantic tokens used by the UI (success/warning/danger/info)

Theme overrides (if any)
- If --accent changes, also change --accent-weak and --ring.
- If --surface or --border changes, also provide --surface-strong and --border-strong.
- Derived tokens are allowed (ex: color-mix) if documented and verified in both modes.
- Light-only or dark-only themes must be explicitly documented as exceptions.

Theme modes
- Dark mode uses a top-level `.dark` class; variants use data attributes (ex: data-theme).
- Themes swap tokens; components keep the same structure across modes.
- Avoid hardcoded colors inside components.

Naming
- “Tag” is the preferred name. “Chip” may remain temporarily if it means sharp tag.


============================================================
4) Layout & Spacing Rhythm
============================================================

- One spacing system per stack (gap/space-y). Avoid ad-hoc mt/mb fixes.
- Default cadence: gap-3 for stacks; gap-2 or dividers for tight lists.
- Grid safety: define columns at all breakpoints; use min-w-0 for truncation.


============================================================
5) Surfaces & Containers
============================================================

- Panel: bordered, opaque, sharp edges.
- Muted panel: subtle background, often borderless.
- Dashed panel: empty/placeholder states.
- Outer containers get borders; inner groupings prefer background only.
- Empty states are content blocks, not interactive elements.


============================================================
6) Lists & Rows (Scan-First)
============================================================

- Use rows for repeated, comparable items (sessions, workspaces, search results, tool calls).
- Prefer a single list container + separators; avoid bordered tiles with gaps.
- Interactive row states must exist:
  - Hover: subtle background change
  - Focus-visible: high-contrast indicator
  - Active/pressed: stronger background change
  - Selected: left accent bar + background shift
    - Exception: if a row already has a dedicated selection indicator (checkbox/radio/toggle/status chip),
      the left bar may be omitted. The indicator must be consistent and not color-only.
- Selection vs focus are distinct; UI must support both.
- Use tabular-nums for numeric-heavy columns.


============================================================
7) Focus & Keyboard
============================================================

- Use focus-visible (keyboard-only). Use the single ring token (--ring) with a small offset.
- Do not clip focus; avoid overflow-hidden on focusable ancestors.
- One primary focus cue per component: rows use background; controls use ring.
- ARIA sanity: only use attributes valid for the role/element.
- Hover-only affordances must appear on focus-within.
- Hidden inputs (sr-only) require visible focus-within styling on the wrapper.


============================================================
8) Controls & Inputs
============================================================

- Sharp edges, opaque background, border-driven hierarchy.
- Error states use border + text (no shadows).
- Keep control heights consistent (ex: h-9) for aligned focus geometry.
- Selects: sharp trigger, row-like options, Esc closes, Enter/Space selects.
- Toggles: prefer checkbox-style; avoid rounded switch dependencies.


============================================================
9) Tags (Status, Labels, Chips)
============================================================

- Tags are informational labels, not decorative pills.
- Keep variants minimal: base, muted, solid.
- If state matters, add a non-color cue (fill/hollow, text tone, explicit label, sr-only).
- Status indicator: small square (filled vs hollow) is preferred.
- Reserve width for swapping labels (overlay pattern).


============================================================
10) Content Blocks (Conversation, Markdown, Code)
============================================================

- Narrative content stays block-based; avoid grid/table layouts for turns.
- Code blocks: sharp container (border + solid bg, no radius).
- Inline code: minimal (border or subtle background, no pill).
- Highlights: subtle, sharp, use --highlight; avoid marker colors.


============================================================
11) Copy & Label Stability
============================================================

- Any swapping label must reserve width (overlay pattern).
- CopyButton: overlay labels, aria-live announcement, no layout shift, focus-visible.


============================================================
12) Modals & Overlays
============================================================

- Modal surface is opaque + bordered; no blur or shadow hierarchy.
- Single scrim token for backdrop.
- Focus-visible must remain obvious inside the modal.


============================================================
13) Motion
============================================================

- Motion is functional, not decorative.
- Respect prefers-reduced-motion (reduce durations, remove repeats/parallax).


============================================================
14) Exceptions Policy
============================================================

- Keep exceptions small and localized.
- Document inline + here if recurring/system-wide.
- Prefer fixing upstream styling hooks over accepting inconsistencies.


== TERMINAL-ADJACENT MESSAGE RENDERING RULES ==

Goals
- Terminal-adjacent readability, accuracy, safety, and resilience.

Font policy
- UI chrome uses UI font; conversation content is mono-forward.
- No font switching inside content; emphasis uses weight/style.
- Choose a mono font with usable bold/italic (or map <em> to underline).

Rendering policy
- User messages: literal text, preserve whitespace, pre-wrap; optional “Render Markdown” toggle.
- Assistant/thought: sanitized markdown (GFM ok), subtle headings, sharp code blocks, minimal inline code.
- Tool/meta output: literal preformatted blocks only.
- Token telemetry: structured UI, not markdown.

Fallback & security
- Wrap markdown renderers in an error boundary; fall back to literal pre on failure.
- Never render unsanitized HTML. Restrict allowed elements/attributes when needed.

Copy + search
- Always support copying raw source (user raw, assistant markdown/plaintext).
- Copy interactions must avoid layout shift (reserve labels).
- Search highlighting must not break code blocks or inline code.

End of guide.
